\documentclass[12pt]{article}

\usepackage{fullpage}
\usepackage{multicol,multirow}
\usepackage{tabularx}
\usepackage{ulem}
\usepackage[utf8]{inputenc}
\usepackage[russian]{babel}

\usepackage{pgfplots}
% \pgfplotsset{compat=1.9}


% Оригиналный шаблон: http://k806.ru/dalabs/da-report-template-2012.tex

\begin{document}

\section*{Лабораторная работа №\,1 по курсу дискрeтного анализа: сортировка за линейное время}

Выполнил студент группы 08-208 МАИ \textit{Попов Матвей}.

\subsection*{Условие}

% Кратко описывается задача: 
\begin{enumerate}
\item Требуется разработать программу, осуществляющую ввод пар «ключ-значение», их упорядочивание по возрастанию ключа указанным алгоритмом сортировки за линейное время и вывод отсортированной последовательности.
\item Вариант задания: Сортировка подсчётом.
\item Тип ключа: числа от 0 до 65535.
\item Тип значения: строки фиксированной длины 64 символа, во входных данных могут встретиться строки меньшей длины, при этом строка дополняется до 64-х нулевыми символами, которые не выводятся на экран. 
\end{enumerate}

\subsection*{Метод решения}

Для сортировки подсчётом исходного массива пар «ключ - значение» создадим два вспомогательных массива: count для счётчика и ans для отсортированного массива.
Заполняем массив count нулями, затем увеличиваем count[raw[i]] на 1 для каждого raw[i]. 
Затем к каждому count[i], начиная с count[1], прибавим count[i - 1], чтобы знать количество меньших или равных элементов для каждого элемента исходного массива.
Наконец прочитаем с конца (для устойчивости) исходный массив, значение count[raw[i]] уменьшим на 1 и в ans[count[raw[i]]] запишем raw[i].  

\subsection*{Описание программы}

Из-за проблем с чекером вся программа была переписана в один файл lab.cpp, был реализован класс TPair для хранения пар «ключ-значение», функция Count ддя заполнения массива count и функция Sort для заполнения массива ans.

\subsection*{Дневник отладки}

\begin{enumerate}
\item Возникли сложности с работой чекера и Makefile, было принято решение переписать программу в один файл, чтобы не тратить попытки напрасно.
\item Превышено максимальное время выполнения на тесте 13, было принято решение отключить синхронизацию ввода-вывода с библиотекой stdio
\item Превышено максимальное количество памяти, было принято решение в массиве ans хранить не пару «ключ - значение», а индекс элемента в исходном массиве, таким образом уменьшили занимаемый массивом ans объём памяти.
\end{enumerate}


\subsection*{Тест производительности}

Ниже приведён график зависимости времени выполнения программы (по оси Y в миллисекундах) от количества пар «ключ - значение» (по оси X, в тысячах), как мы видим, сложность соответствует линейной.

\begin{tikzpicture}
    \begin{axis}
    \addplot coordinates {
        (10000,6652) (20000,12968) (30000,20906) (40000,26397) (50000,33691)
    };
    \end{axis}
\end{tikzpicture}


\subsection*{Недочёты}

Единственным недочётом является то, что вся программа сделана в одном файле, хотя можно было бы, например, реализацию класса TPair вынести в отдельный заголовочный файл.
Как отмечалось ранее, на это пришлось пойти из-за проблем с чекером. Тем не менее, программа не выглядит из-за этого громоздко, так как её размер не превысил 80 строк.

\subsection*{Выводы}

При выполнении лабораторной работы была написана программа сортировки за линейное время. Она может быть полезна в ситуации, когда во входящей последовательности много повторяющихся ключей, по которым сортируются элементы.
Также важно помнить, что сортировка подсчётом хоть и работает за линейное время, но требует дополнительную память.

\end{document}
