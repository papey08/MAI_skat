\documentclass[12pt]{article}
\usepackage{fullpage}
\usepackage{multicol,multirow}
\usepackage{tabularx}
\usepackage{ulem}
\usepackage[utf8]{inputenc}
\usepackage[russian]{babel}

\usepackage{pgfplots}

\begin{document}
    
    \section*{Лабораторная работа №\,4 по курсу дискрeтного анализа: Поиск 
    образца в строке}

    Выполнил студент группы М8О-208Б-20 МАИ \textit{Попов Матвей}.

    \subsection*{Условие}

    \begin{enumerate}
        \item \textbf{Упрощённый вариант:} поиск одного образца в тексте с 
        помощью алгоритма Z-блоков.
        \item \textbf{Алфавит:} сторчные латинские буквы.
    \end{enumerate}

    \subsection*{Метод решения}
    Создадим строку, состоящую из образца и текста, разделённых символом, не 
    входящим в алфавит, и определим Z-функцию этой строки. Индекс элементов 
    Z-функции, равных длине образца, будет определять позицию вхождения 
    образца в тексте. 

    \subsection*{Дневник отладки}
    \begin{enumerate}
        \item Программа была написана примерно за 20 минут без ошибок, это же 
        не Ахо-Корасик с шакальным вводом.
    \end{enumerate}

    \subsection*{Тест производительности}
    Сравнение производительности производилось с наивным алгоритмом поиска 
    подстроки. Во всех графиках по оси Y отложено время выполнения 
    (в миллисекундах), по оси X — количество символов в строке, 
    делённое на 50.

    \begin{tikzpicture}
        \begin{axis}
            [legend pos = north west, ymin = 0]
            \legend{
                Z-блоки, Наивный алгоритм
            };
            \addplot coordinates {
                (1000, 1007) (10000, 10840) (100000, 111367)
            };
            \addplot coordinates {
                (1000, 1097) (10000, 11028) (100000, 129790)
            };
        \end{axis}
    \end{tikzpicture}

    \begin{tabular}{ | c | c | c | }
        \hline
            Кол-во строк & Z-блоки & Наивный алгоритм \\ \hline
            1000 & 1007 & 1097 \\
            10000 & 10840 & 11028 \\
            100000 & 111367 & 129790 \\
        \hline
    \end{tabular}
    \\Таким образом, алгоритм Z-блоков оказался немного быстрее наивного 
    алгоритма, так как длина образца во всех тестах была сравнительно 
    небольшой, однако стоит понимать, что с увеличением длины образца 
    будет увеличиваться и разница во времени работы алгоритмов.

    \subsection*{Выводы}
    Проделав лабораторную работу, я реализовал алгоритм поиска подстроки в 
    строке, построение Z-функции работает за $O(n + m)$, где $n$ — длина 
    образца, а $m$ — длина текста, а поиск всех вхождений работает за $O(m)$. 
    Это гораздо эффективнее наивного алгоритма, который в худшем случае 
    работает за $O(nm)$. Также положительной чертой этого алгоритма является 
    то, что он относительно прост для понимания.

\end{document}
