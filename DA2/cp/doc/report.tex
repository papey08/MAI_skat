\documentclass[12pt]{article}
\usepackage{fullpage}
\usepackage{multicol,multirow}
\usepackage{tabularx}
\usepackage{ulem}
\usepackage[utf8]{inputenc}
\usepackage[russian]{babel}
\usepackage{pgfplots}

\begin{document}

    \section*{Курсовой проект по курсу дискрeтного анализа: 
    Алгоритм LZ77}

    Выполнил студент группы М8О-308Б-20 МАИ \textit{Попов Матвей}.

    \subsection*{Условие}
    
    Ваша программа должна читать входные данные из стандартного
    потока ввода и выводить ответ на стандартный поток вывода.
    Вам будут даны входные файлы двух типов.
    
    \begin{enumerate}
    \item Первый тип: текст состоит только из малых латинских букв. В ответ на 
        него вам нужно вывести тройки, которыми будет закодирован данный текст.
    \item Второй тип: вам даны тройки (<offset, len, char>) в которые был сжат 
    текст из малых латинских букв, вам нужно его разжать.    
    \end{enumerate}

    \subsection*{Метод решения}

    Была реализована структура для хранения триплетов, а также функции 
    \textit{Compress}, которая принимает на вход строку и возвращает массив 
    триплетов, и \textit{Decompress}, которая принимает на вход массив 
    триплетов и декодирует их в строку.

    \subsection*{Описание программы}

    Программа состоит из пяти файлов: \textit{Compress.hpp}, содержащий функцию
    для кодирования, \textit{Decompress.hpp}, содержащий функцию для 
    декодирования, \textit{TTriplet.hpp}, содержащий структуру триплетов, 
    \textit{main.cpp} и \textit{Makefile} для сборки программы.

    \subsection*{Дневник отладки}

    \begin{enumerate}
    \item Было принято решение сперва написать функцию для декодирования, чтобы 
        в дальнейшем была возможность проверить корректность работы функции 
        кодирования.
    \item Функция для декодирования была написана без ошибок
    \item В функции для кодирования была допущена ошибка при работе со 
    скользящим окном 
    \end{enumerate}


    \subsection*{Тест производительности}

    По оси X — количество символов в тексте, по оси Y — время работы алгоритмов 
    в мс (меньше — лучше).
    
    \begin{tikzpicture}
        \begin{axis} [
            legend pos = north west,
            ymin = 0
        ]
        \legend{
            Кодирование,
            Декодирование
        };
        \addplot coordinates {
            (1000, 271) (10000,2163) (100000,19312)
        };
        \addplot coordinates {
            (1000,7) (10000,9) (100000,44)
        };
        \end{axis}
    \end{tikzpicture}

    \begin{tabular}{ | l | l | l | }
        \hline
            Кол-во символов & Кодирование & Декодирование \\ \hline
            1000            & 271         & 7             \\
            10000           & 2163        & 9             \\
            100000          & 19312       & 44            \\
        \hline
    \end{tabular}

    \subsection*{Тест сжатия}

    По оси X — количество символов в исходной строке, по оси Y — количество 
    триплетов в закодированной последовательности.

    \begin{tikzpicture}
        \begin{axis} [
            ymin = 0
        ]
        \addplot coordinates {
            (1000, 416) (10000, 3214) (100000, 25656)
        };
        \end{axis}
    \end{tikzpicture}

    \begin{tabular}{ | l | l | l | }
        \hline
            Кол-во символов & Кол-во триплетов \\ \hline
            1000            & 416              \\
            10000           & 3214             \\
            100000          & 25656            \\
        \hline
    \end{tabular}

    \subsection*{Недочёты}

    Отсутствует буферизация закодированной части текста, то есть поиск 
    наибольшей подстроки, которую предстоит закодировать, осуществляется во 
    всей уже закодированной подстроке. Это обеспечивает наименьшую 
    последовательность триплетов, но негативно сказывается на времени работы 
    кодировки. Помимо этого алгоритм поиска наивный, из-за чего сложность по 
    времени в худшем случае является $O(n^3)$, что хуже, если бы в основе 
    поиска лежало бы суффиксное дерево ($O(n^2)$), однако тест 
    производительности показывает, что даже с наивным алгоритмом сложность 
    близка к линейной. 

    \subsection*{Выводы}

    Таким образом был реализован алгоритм кодирования LZ77. Его преимуществами 
    являются простота реализации и высокая скорость декодирования. Недостатком 
    является то, что алгоритм кодирования неэффективен на малых объёмах данных, 
    ведь даже на тексте в 100000 символов итоговый размер триплетов превышает 
    размер исходной строки, однако по графику видно, что с увеличением длины 
    строки отношение количества триплетов к длине строки уменьшается, а значит 
    алгоритм работает.

\end{document}
