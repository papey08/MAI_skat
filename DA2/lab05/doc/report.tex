\documentclass[12pt]{article}
\usepackage{fullpage}
\usepackage{multicol,multirow}
\usepackage{tabularx}
\usepackage{ulem}
\usepackage[utf8]{inputenc}
\usepackage[russian]{babel}
\usepackage{pgfplots}


\begin{document}

    \section*{Лабораторная работа №\,5 по курсу дискрeтного анализа: 
    Суффиксные деревья}

    Выполнил студент группы М8О-308Б-20 МАИ \textit{Попов Матвей}.

    \subsection*{Условие}
 
    \begin{enumerate}
    \item Необходимо реализовать алгоритм Укконена построения суффиксного
    дерева за линейное время. Построив такое дерево для некоторых из
    входных строк, необходимо воспользоваться полученным суффиксным
    деревом для решения своего варианта задания.
    \item Вариант задания: поиск в известном тексте неизвестных заранее образцов
    \end{enumerate}

    \subsection*{Метод решения}

    Реализован класс суффиксного дерева, в качестве конструктора использовался
    алгоритм Укконена, для которого специально было введено 5 полей в классе.
    Для реализации алгоритма поиска был реализован метод \textit{Search}, 
    возвращающий множество вхождений аргумента в текст, по которому было 
    построено дерево. Отличительной особенностью программы является то, что в 
    ней нет рекурсии.

    \subsection*{Описание программы}

    Программа состоит из трёх файлов: \textit{TSuffixTree.hpp} с реализацией 
    суффиксного дерева и необходимых алгоритмов, \textit{main.cpp} и 
    \textit{Makefile} для сборки программы.

    \subsection*{Дневник отладки}

    \begin{enumerate}
    \item После нескольких неудачных попыток реализации алгоритма Укконена было
    принято решение выделить некоторые необходимые переменные в поля класса 
    суффиксного дерева, чтобы запоминать необходимые значения даже после 
    окончания работы функции вставки одного суффикса.
    \item Было принято решение заменть тип возвращаемого значения метода 
    \textit{Search} с вектора на множество, чтобы не беспокоиться о сортировке 
    возвращаемых результатов, а также для более эффективного расхода памяти. 
    \end{enumerate}


    \subsection*{Тест производительности}

    Ниже приведено сравнение времени работы наивного алгоритма построения 
    суффиксного дерева и алгоритма Укконена. По оси $X$ — количество символов в
    тексте, по оси $Y$ — время построения суффиксного дерева в милисекундах 
    (меньше — лучше).
    
    \begin{tikzpicture}
        \begin{axis} [
            legend pos = north west,
            ymin = 0
        ]
        \legend{
            Наивный,
            Укконен
        };
        \addplot coordinates {
            (1000,72) (10000,7028) (100000,911808)
        };
        \addplot coordinates {
            (1000,1) (10000,16) (100000,185)
        };
        \end{axis}
    \end{tikzpicture}

    \begin{tabular}{ | l | l | l | }
        \hline
            Кол-во символов & Наивный & Укконен \\ \hline
            1000            & 72      & 1       \\
            10000           & 7028    & 16      \\
            100000          & 911808  & 185    \\
        \hline
    \end{tabular}

    Из тестов ясно видно, что наивный алгоритм работает за $O(n^2)$, а алгоритм 
    Укконена — за линейное время.

    \subsection*{Недочёты}

    Эта лабораторная работа стала первой, выполненной в нескольких файлах и 
    задействующей систему сборки \textit{Make}, однако всё ещё есть недостатки,
    например заголовочный файл содержит и определение, и реализацию методов, 
    а их можно было бы разбить на два файла.

    \subsection*{Выводы}

    Проделав лабораторную работу, познакомился с практическим применением 
    суффиксного дерева, а также с алгоритмом Укконена, который делает эту 
    структуру данных пожалуй наиболее удобным решением задач поиска множества 
    неизвестных образцов в заранее известном тексте.

\end{document}
