\documentclass[12pt]{article}
\usepackage{fullpage}
\usepackage{multicol,multirow}
\usepackage{tabularx}
\usepackage{ulem}
\usepackage[utf8]{inputenc}
\usepackage[russian]{babel}
\usepackage{pgfplots}


\begin{document}

    \section*{Лабораторная работа №\,7 по курсу дискрeтного анализа: 
    Динамическое программирование}

    Выполнил студент группы М8О-308Б-20 МАИ \textit{Попов Матвей}.

    \subsection*{Условие}
 
    \begin{enumerate}
    \item При помощи метода динамического программирования разработать алгоритм 
    решения задачи, определяемой своим вариантом; оценить время выполнения 
    алгоритма и объем затрачиваемой оперативной памяти. Перед выполнением 
    задания необходимо обосновать применимость метода динамического 
    программирования.
    \item \textbf{Вариант 1: Хитрый рюкзак.} У вас есть рюкзак, вместимостью 
    $m$, а также $n$ предметов, у каждого из которых есть вес $w_i$ и 
    стоимость $c_i$. Необходимо выбрать такое подмножество $I$ из них, чтобы
    \begin{itemize}
        \item $\sum\limits_{i \in I} w_i \leq m$
        \item $(\sum\limits_{i \in I} c_i) \ast |I|$ является максимальной из всех 
        возможных
    \end{itemize}
    $|I|$ — мощность множества $I$.
    \end{enumerate}

    \subsection*{Метод решения}

    Для решения воспользуемся методом динамического программирования, в котором 
    большая задача разбивается на множество маленьких подзадач, решения каждой 
    из которых может быть использовано несколько раз, что сильно увеличивает 
    производительность алгоритма. Вспомним решение изветсной задачи о рюкзаке: 
    составим таблицу из $n$ строк и $m$ столбцов и заполним каждую ячейку по 
    определённому правилу, причём в заполнении каждой ячейки будут участвовать 
    уже заполненные ячейки, в итоге в правой нижней ячейке нашей таблицы будет 
    лежать решение задачи, то есть максимальная стоимость, которую можно унести 
    в рюкзаке. Задача из моего варианта отличается от оригинальной условием 
    заполнения таблицы, а также тем, что нужно хранить вспомогательную таблицу 
    для восстановления последовательности предметов.

    \subsection*{Описание программы}

    Программа состоит из одного файла.

    \subsection*{Дневник отладки}

    \begin{enumerate}
    \item Было несколько неудачных попыток, все они связаны с неправильным 
    выбором типа переменной для хранения стоимости предметов. 
    \end{enumerate}


    \subsection*{Тест производительности}

    Ниже приведен тест времени работы алгоритма. По оси $X$ — количество 
    предметов, по оси $Y$ — время выполнения алгоритма в мс (меньше — лучше).
    
    \begin{tikzpicture}
        \begin{axis} [
            ymin = 0
        ]
        \addplot coordinates {
            (100,51) (250,749) (500,8391)
        };
        \end{axis}
    \end{tikzpicture}

    \begin{tabular}{ | l | l | l | }
        \hline
            Кол-во предметов & Время (в мс) \\ \hline
            100              & 51           \\
            250              & 749          \\
            500              & 8391         \\
        \hline
    \end{tabular}

    Тесты подтвердили временную сложность алгоритма — $O(n^2m)$, что гораздо 
    лучше простого перебора за $O(2^n)$

    \subsection*{Недочёты}

    В процессе выполнения работы не использовалось дополнительных классов или 
    функций, из-за чего программисту, незнакомому с алгоритмом, будет очень 
    сложно разбираться в коде.

    \subsection*{Выводы}

    Проделав лабораторную работу, познакомился с новым подходом решения 
    алгоритмических задач — динамическим программированием, а также впервые 
    за всё время использовал класс std::bitset в своей программе.

\end{document}
