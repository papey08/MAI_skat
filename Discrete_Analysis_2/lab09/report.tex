\documentclass[12pt]{article}
\usepackage{fullpage}
\usepackage{multicol,multirow}
\usepackage{tabularx}
\usepackage{ulem}
\usepackage[utf8]{inputenc}
\usepackage[russian]{babel}
\usepackage{pgfplots}

\begin{document}

    \section*{Лабораторная работа №\,9 по курсу дискрeтного анализа: 
    Графы}

    Выполнил студент группы М8О-308Б-20 МАИ \textit{Попов Матвей}.

    \subsection*{Условие}
 
    \begin{enumerate}
    \item Разработать программу на языке C или C++, реализующую указанный
    алгоритм. Формат входных и выходных данных описан в варианте задания.
    Первый тест в проверяющей системе совпадает с примером.
    \item \textbf{Вариант 4: Поиск кратчайшего пути между парой вершин
    алгоритмом Дейкстры.} Задан взвешенный неориентированный граф, состоящий 
    из $n$ вершин и $m$ рёбер. Вершины пронумерованы целыми числами от $1$ до 
    $n$. Необходимо найти длину кратчайшего пути из вершины с номером $start$ в 
    вершину с номером $finish$ при помощи алгоритма Дейкстры. Длина пути равна
    сумме весов ребер на этом пути. Граф не содержит петель и кратных рёбер.
    \end{enumerate}

    \subsection*{Метод решения}

    Алгоритм Дейкстры является одним из самых распространённых способов найти 
    кратчайший путь между двумя вершинами в графе. Его недостатком является то, 
    что он не работает в графах с рёбрами с отрицательным весом. Его 
    перимущество заключается в том,что он ищет кратчайшие пути от заданной 
    вершины до вообще всех остальных вершин (хотя в рамках поставленной задачи
    это будет лишним).

    Первым делом сопоставим каждой вершине графа некое число — то самое 
    наименьшее расстояние от неё до начальной вершины, у начальной вершины это 
    будет очевидно $0$, у всех остальных бесконечность, то есть достаточно 
    большое число, затем для каждой вершины, связанной с начальной ровно $1$ 
    ребром проверим, является ли сопоставленное ей в начале число больше, чем 
    сумма такого же числа той вершины, из которой мы приши и веса ребра, по 
    которому пришли. Если является, заменяем число на эту самую сумму. Как 
    только обошли всех соседей вершины, помечаем вершину как пройденную, это 
    значит, что минимальное расстояние до этой вершины найдено и изменять его 
    больше не надо. То же самое делаем со всеми остальными вершинами, пользуясь 
    поиском в глубину.

    \subsection*{Описание программы}

    Программа состоит из одного файла.

    \subsection*{Дневник отладки}

    \begin{enumerate}
    \item Наученный горьким опытом предыдущих задач, я заменил тип int32 на 
    int64.
    \item Программа переписана с нуля, заменены некоторые структуры данных.
    \item Вместо структуры TEdge для рёбер было принято решение использовать
    std::pair. Это оказалось удобнее.
    \end{enumerate}

    \subsection*{Тест производительности}

    Ниже приведен тест времени работы алгоритма. По оси $X$ — количество 
    вершин в графе (количество рёбер на каждом тесте в $e$ раз больше 
    количества вершин), по оси $Y$ — время выполнения алгоритма в мс (меньше 
    — лучше).
    
    \begin{tikzpicture}
        \begin{axis} [
            ymin = 0
        ]
        \addplot coordinates {
            (1000,10) (10000,115) (100000,1453)
        };
        \end{axis}
    \end{tikzpicture}

    \begin{tabular}{ | l | l | l | }
        \hline
            Кол-во вершин    & Время (в мс) \\ \hline
            1000             & 10           \\
            10000            & 115          \\
            100000           & 1453         \\
        \hline
    \end{tabular}

    Мы не получили ожидаемой сложности $O(n^2)$, так как наш алгоритм 
    завершается сразу, как только конечная вершина оказалась помеченной. 
    Благодаря этому ускоернию сложность стремится к линейной.

    \subsection*{Недочёты}

    Эта лабораторная работа стала первой и, к сожалению, последней, где я не 
    могу выявить очевидных недочётов.

    \subsection*{Выводы}

    Проделав лабораторную работу, реализовал вариацию алгоритма Дейкстры, 
    имеющего широкое прикладное применение в построении маршрутов и не только.

\end{document}
